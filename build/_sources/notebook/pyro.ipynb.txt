{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "outputs": [],
   "source": [
    "%reset -s -f"
   ],
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%%\n"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "outputs": [],
   "source": [
    "import ssl\n",
    "ssl._create_default_https_context = ssl._create_unverified_context"
   ],
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%%\n"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "import os\n",
    "from functools import partial\n",
    "import torch\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import seaborn as sns\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "import pyro\n",
    "import pyro.distributions as dist\n",
    "\n",
    "# for CI testing\n",
    "smoke_test = ('CI' in os.environ)\n",
    "assert pyro.__version__.startswith('1.3')\n",
    "pyro.enable_validation(True)\n",
    "pyro.set_rng_seed(1)\n",
    "pyro.enable_validation(True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "outputs": [],
   "source": [
    "DATA_URL = \"https://d2hg8soec8ck9v.cloudfront.net/datasets/rugged_data.csv\"\n",
    "data = pd.read_csv(DATA_URL, encoding=\"ISO-8859-1\")\n",
    "df = data[[\"cont_africa\", \"rugged\", \"rgdppc_2000\"]]\n",
    "df = df[np.isfinite(df.rgdppc_2000)]\n",
    "df[\"rgdppc_2000\"] = np.log(df[\"rgdppc_2000\"])"
   ],
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%%\n"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "outputs": [
    {
     "data": {
      "text/plain": "<Figure size 864x432 with 2 Axes>",
      "image/png": "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\n"
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "fig, ax = plt.subplots(nrows=1, ncols=2, figsize=(12, 6), sharey=True)\n",
    "african_nations = df[df[\"cont_africa\"] == 1]\n",
    "non_african_nations = df[df[\"cont_africa\"] == 0]\n",
    "sns.scatterplot(non_african_nations[\"rugged\"],\n",
    "            non_african_nations[\"rgdppc_2000\"],\n",
    "            ax=ax[0])\n",
    "ax[0].set(xlabel=\"Terrain Ruggedness Index\",\n",
    "          ylabel=\"log GDP (2000)\",\n",
    "          title=\"Non African Nations\")\n",
    "sns.scatterplot(african_nations[\"rugged\"],\n",
    "                african_nations[\"rgdppc_2000\"],\n",
    "                ax=ax[1])\n",
    "ax[1].set(xlabel=\"Terrain Ruggedness Index\",\n",
    "          ylabel=\"log GDP (2000)\",\n",
    "          title=\"African Nations\");"
   ],
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%%\n"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "outputs": [],
   "source": [
    "from torch import nn\n",
    "from pyro.nn import PyroModule\n",
    "\n",
    "assert issubclass(PyroModule[nn.Linear], nn.Linear)\n",
    "assert issubclass(PyroModule[nn.Linear], PyroModule)"
   ],
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%%\n"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[iteration 0050] loss: 3179.7852\n",
      "[iteration 0100] loss: 1616.1375\n",
      "[iteration 0150] loss: 1109.4119\n",
      "[iteration 0200] loss: 833.7546\n",
      "[iteration 0250] loss: 637.5822\n",
      "[iteration 0300] loss: 488.2654\n",
      "[iteration 0350] loss: 376.4651\n",
      "[iteration 0400] loss: 296.0484\n",
      "[iteration 0450] loss: 240.6141\n",
      "[iteration 0500] loss: 203.9386\n",
      "[iteration 0550] loss: 180.6171\n",
      "[iteration 0600] loss: 166.3494\n",
      "[iteration 0650] loss: 157.9457\n",
      "[iteration 0700] loss: 153.1786\n",
      "[iteration 0750] loss: 150.5735\n",
      "[iteration 0800] loss: 149.2020\n",
      "[iteration 0850] loss: 148.5065\n",
      "[iteration 0900] loss: 148.1668\n",
      "[iteration 0950] loss: 148.0070\n",
      "[iteration 1000] loss: 147.9347\n",
      "[iteration 1050] loss: 147.9032\n",
      "[iteration 1100] loss: 147.8900\n",
      "[iteration 1150] loss: 147.8848\n",
      "[iteration 1200] loss: 147.8827\n",
      "[iteration 1250] loss: 147.8819\n",
      "[iteration 1300] loss: 147.8817\n",
      "[iteration 1350] loss: 147.8816\n",
      "[iteration 1400] loss: 147.8815\n",
      "[iteration 1450] loss: 147.8815\n",
      "[iteration 1500] loss: 147.8815\n",
      "Learned parameters:\n",
      "weight [[-1.9478593  -0.20278622  0.39330277]]\n",
      "bias [9.22308]\n"
     ]
    }
   ],
   "source": [
    "# Dataset: Add a feature to capture the interaction between \"cont_africa\" and \"rugged\"\n",
    "df[\"cont_africa_x_rugged\"] = df[\"cont_africa\"] * df[\"rugged\"]\n",
    "data = torch.tensor(df[[\"cont_africa\", \"rugged\", \"cont_africa_x_rugged\", \"rgdppc_2000\"]].values,\n",
    "                        dtype=torch.float)\n",
    "x_data, y_data = data[:, :-1], data[:, -1]\n",
    "\n",
    "# Regression model\n",
    "linear_reg_model = PyroModule[nn.Linear](3, 1)\n",
    "\n",
    "# Define loss and optimize\n",
    "loss_fn = torch.nn.MSELoss(reduction='sum')\n",
    "optim = torch.optim.Adam(linear_reg_model.parameters(), lr=0.05)\n",
    "num_iterations = 1500 if not smoke_test else 2\n",
    "\n",
    "def train():\n",
    "    # run the model forward on the data\n",
    "    y_pred = linear_reg_model(x_data).squeeze(-1)\n",
    "    # calculate the mse loss\n",
    "    loss = loss_fn(y_pred, y_data)\n",
    "    # initialize gradients to zero\n",
    "    optim.zero_grad()\n",
    "    # backpropagate\n",
    "    loss.backward()\n",
    "    # take a gradient step\n",
    "    optim.step()\n",
    "    return loss\n",
    "\n",
    "for j in range(num_iterations):\n",
    "    loss = train()\n",
    "    if (j + 1) % 50 == 0:\n",
    "        print(\"[iteration %04d] loss: %.4f\" % (j + 1, loss.item()))\n",
    "\n",
    "\n",
    "# Inspect learned parameters\n",
    "print(\"Learned parameters:\")\n",
    "for name, param in linear_reg_model.named_parameters():\n",
    "    print(name, param.data.numpy())\n"
   ],
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%%\n"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "outputs": [],
   "source": [
    "from pyro.nn import PyroSample\n",
    "\n",
    "\n",
    "class BayesianRegression(PyroModule):\n",
    "    def __init__(self, in_features, out_features):\n",
    "        super().__init__()\n",
    "        self.linear = PyroModule[nn.Linear](in_features, out_features)\n",
    "        self.linear.weight = PyroSample(dist.Normal(0., 1.).expand([out_features, in_features]).to_event(2))\n",
    "        self.linear.bias = PyroSample(dist.Normal(0., 10.).expand([out_features]).to_event(1))\n",
    "\n",
    "    def forward(self, x, y=None):\n",
    "        sigma = pyro.sample(\"sigma\", dist.Uniform(0., 10.))\n",
    "        mean = self.linear(x).squeeze(-1)\n",
    "        with pyro.plate(\"data\", x.shape[0]):\n",
    "            obs = pyro.sample(\"obs\", dist.Normal(mean, sigma), obs=y)\n",
    "        return mean"
   ],
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%%\n"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "outputs": [],
   "source": [
    "from pyro.infer.autoguide import AutoDiagonalNormal\n",
    "\n",
    "model = BayesianRegression(3, 1)\n",
    "guide = AutoDiagonalNormal(model)"
   ],
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%%\n"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "outputs": [],
   "source": [
    "from pyro.infer import SVI, Trace_ELBO\n",
    "adam = pyro.optim.AdamW({\"lr\": 0.1})\n",
    "svi = SVI(model, guide, adam, loss=Trace_ELBO())"
   ],
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%%\n"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[iteration 0001] loss: 6.2310\n",
      "[iteration 0101] loss: 3.0857\n",
      "[iteration 0201] loss: 1.4532\n",
      "[iteration 0301] loss: 1.4656\n",
      "[iteration 0401] loss: 1.4658\n",
      "[iteration 0501] loss: 1.4618\n",
      "[iteration 0601] loss: 1.4717\n",
      "[iteration 0701] loss: 1.4594\n",
      "[iteration 0801] loss: 1.5042\n",
      "[iteration 0901] loss: 1.4646\n",
      "[iteration 1001] loss: 1.4783\n",
      "[iteration 1101] loss: 1.4696\n",
      "[iteration 1201] loss: 1.4751\n",
      "[iteration 1301] loss: 1.4779\n",
      "[iteration 1401] loss: 1.4672\n"
     ]
    }
   ],
   "source": [
    "pyro.clear_param_store()\n",
    "for j in range(num_iterations):\n",
    "    # calculate the loss and take a gradient step\n",
    "    loss = svi.step(x_data, y_data)\n",
    "    if j % 100 == 0:\n",
    "        print(\"[iteration %04d] loss: %.4f\" % (j + 1, loss / len(data)))\n"
   ],
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%%\n"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "AutoDiagonalNormal.loc Parameter containing:\n",
      "tensor([-2.2085, -1.7068, -0.1347,  0.3600,  9.1465])\n",
      "AutoDiagonalNormal.scale tensor([0.0593, 0.1313, 0.0347, 0.0653, 0.0513])\n"
     ]
    }
   ],
   "source": [
    "guide.requires_grad_(False)\n",
    "\n",
    "for name, value in pyro.get_param_store().items():\n",
    "    print(name, pyro.param(name))"
   ],
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%%\n"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "outputs": [
    {
     "data": {
      "text/plain": "{'sigma': [tensor(0.9899)],\n 'linear.weight': [tensor([[-1.7068, -0.1347,  0.3600]])],\n 'linear.bias': [tensor([9.1465])]}"
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "guide.quantiles([0.5])"
   ],
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%%\n"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "outputs": [
    {
     "data": {
      "text/plain": "['__call__',\n '__class__',\n '__delattr__',\n '__dict__',\n '__dir__',\n '__doc__',\n '__eq__',\n '__format__',\n '__ge__',\n '__getattr__',\n '__getattribute__',\n '__gt__',\n '__hash__',\n '__init__',\n '__init_subclass__',\n '__le__',\n '__lt__',\n '__module__',\n '__ne__',\n '__new__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__setattr__',\n '__setstate__',\n '__sizeof__',\n '__str__',\n '__subclasshook__',\n '__weakref__',\n '_apply',\n '_backward_hooks',\n '_buffers',\n '_cond_indep_stacks',\n '_create_plates',\n '_forward_hooks',\n '_forward_pre_hooks',\n '_get_name',\n '_init_loc',\n '_init_scale',\n '_load_from_state_dict',\n '_load_state_dict_pre_hooks',\n '_loc_scale',\n '_model',\n '_modules',\n '_named_members',\n '_parameters',\n '_prototype_frames',\n '_pyro_context',\n '_pyro_get_fullname',\n '_pyro_name',\n '_pyro_params',\n '_pyro_samples',\n '_pyro_set_supermodule',\n '_register_load_state_dict_pre_hook',\n '_register_state_dict_hook',\n '_replicate_for_data_parallel',\n '_save_to_state_dict',\n '_setup_prototype',\n '_slow_forward',\n '_state_dict_hooks',\n '_unconstrained_shapes',\n '_unpack_latent',\n '_update_master',\n '_version',\n 'add_module',\n 'apply',\n 'bfloat16',\n 'buffers',\n 'call',\n 'children',\n 'cpu',\n 'create_plates',\n 'cuda',\n 'double',\n 'dump_patches',\n 'eval',\n 'extra_repr',\n 'float',\n 'forward',\n 'get_base_dist',\n 'get_posterior',\n 'get_transform',\n 'half',\n 'latent_dim',\n 'load_state_dict',\n 'loc',\n 'master',\n 'median',\n 'model',\n 'modules',\n 'named_buffers',\n 'named_children',\n 'named_modules',\n 'named_parameters',\n 'named_pyro_params',\n 'parameters',\n 'plates',\n 'prototype_trace',\n 'quantiles',\n 'register_backward_hook',\n 'register_buffer',\n 'register_forward_hook',\n 'register_forward_pre_hook',\n 'register_parameter',\n 'requires_grad_',\n 'sample_latent',\n 'scale_unconstrained',\n 'share_memory',\n 'state_dict',\n 'to',\n 'train',\n 'training',\n 'type',\n 'zero_grad']"
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "dir(guide)"
   ],
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%%\n"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "outputs": [
    {
     "data": {
      "text/plain": "[('loc',\n  Parameter containing:\n  tensor([-2.2085, -1.7068, -0.1347,  0.3600,  9.1465])),\n ('scale', tensor([0.0593, 0.1313, 0.0347, 0.0653, 0.0513]))]"
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "list(guide.named_pyro_params())"
   ],
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%%\n"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "outputs": [
    {
     "data": {
      "text/plain": "{'AutoDiagonalNormal.loc': Parameter containing:\n tensor([-2.2085, -1.7068, -0.1347,  0.3600,  9.1465]),\n 'AutoDiagonalNormal.scale': tensor([0.0593, 0.1313, 0.0347, 0.0653, 0.0513])}"
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "dict(pyro.get_param_store())"
   ],
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%%\n"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "outputs": [
    {
     "data": {
      "text/plain": "tensor(1.)"
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "cloudy = torch.distributions.Bernoulli(0.3).sample()\n",
    "cloudy\n"
   ],
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%%\n"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "....................\n",
      "based on the data and our prior belief, the fairness of the coin is 0.536 +- 0.090\n"
     ]
    }
   ],
   "source": [
    "import math\n",
    "import os\n",
    "import torch\n",
    "import torch.distributions.constraints as constraints\n",
    "import pyro\n",
    "from pyro.optim import Adam\n",
    "from pyro.infer import SVI, Trace_ELBO\n",
    "import pyro.distributions as dist\n",
    "\n",
    "# this is for running the notebook in our testing framework\n",
    "smoke_test = ('CI' in os.environ)\n",
    "n_steps = 2 if smoke_test else 2000\n",
    "\n",
    "# enable validation (e.g. validate parameters of distributions)\n",
    "assert pyro.__version__.startswith('1.3')\n",
    "pyro.enable_validation(True)\n",
    "\n",
    "# clear the param store in case we're in a REPL\n",
    "pyro.clear_param_store()\n",
    "\n",
    "# create some data with 6 observed heads and 4 observed tails\n",
    "data = []\n",
    "for _ in range(6):\n",
    "    data.append(torch.tensor(1.0))\n",
    "for _ in range(4):\n",
    "    data.append(torch.tensor(0.0))\n",
    "\n",
    "def model(data):\n",
    "    # define the hyperparameters that control the beta prior\n",
    "    alpha0 = torch.tensor(10.0)\n",
    "    beta0 = torch.tensor(10.0)\n",
    "    # sample f from the beta prior\n",
    "    f = pyro.sample(\"latent_fairness\", dist.Beta(alpha0, beta0))\n",
    "    # loop over the observed data\n",
    "    for i in range(len(data)):\n",
    "        # observe datapoint i using the bernoulli likelihood\n",
    "        pyro.sample(\"obs_{}\".format(i), dist.Bernoulli(f), obs=data[i])\n",
    "\n",
    "def guide(data):\n",
    "    # register the two variational parameters with Pyro\n",
    "    # - both parameters will have initial value 15.0.\n",
    "    # - because we invoke constraints.positive, the optimizer\n",
    "    # will take gradients on the unconstrained parameters\n",
    "    # (which are related to the constrained parameters by a log)\n",
    "    alpha_q = pyro.param(\"alpha_q\", torch.tensor(15.0),\n",
    "                         constraint=constraints.positive)\n",
    "    beta_q = pyro.param(\"beta_q\", torch.tensor(15.0),\n",
    "                        constraint=constraints.positive)\n",
    "    # sample latent_fairness from the distribution Beta(alpha_q, beta_q)\n",
    "    pyro.sample(\"latent_fairness\", dist.Beta(alpha_q, beta_q))\n",
    "\n",
    "# setup the optimizer\n",
    "adam_params = {\"lr\": 0.0005, \"betas\": (0.90, 0.999)}\n",
    "optimizer = Adam(adam_params)\n",
    "\n",
    "# setup the inference algorithm\n",
    "svi = SVI(model, guide, optimizer, loss=Trace_ELBO())\n",
    "\n",
    "# do gradient steps\n",
    "for step in range(n_steps):\n",
    "    svi.step(data)\n",
    "    if step % 100 == 0:\n",
    "        print('.', end='')\n",
    "\n",
    "# grab the learned variational parameters\n",
    "alpha_q = pyro.param(\"alpha_q\").item()\n",
    "beta_q = pyro.param(\"beta_q\").item()\n",
    "\n",
    "# here we use some facts about the beta distribution\n",
    "# compute the inferred mean of the coin's fairness\n",
    "inferred_mean = alpha_q / (alpha_q + beta_q)\n",
    "# compute inferred standard deviation\n",
    "factor = beta_q / (alpha_q * (1.0 + alpha_q + beta_q))\n",
    "inferred_std = inferred_mean * math.sqrt(factor)\n",
    "\n",
    "print(\"\\nbased on the data and our prior belief, the fairness \" +\n",
    "      \"of the coin is %.3f +- %.3f\" % (inferred_mean, inferred_std))"
   ],
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%%\n"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "outputs": [
    {
     "data": {
      "text/plain": "[tensor(1.),\n tensor(1.),\n tensor(1.),\n tensor(1.),\n tensor(1.),\n tensor(1.),\n tensor(0.),\n tensor(0.),\n tensor(0.),\n tensor(0.)]"
     },
     "execution_count": 19,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "data\n"
   ],
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%%\n"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Doing inference with use_decaying_avg_baseline=True\n",
      "..\n",
      "Did 128 steps of inference.\n",
      "Final absolute errors for the two variational parameters were 0.7990 & 0.7997\n",
      "Doing inference with use_decaying_avg_baseline=False\n",
      "....\n",
      "Did 394 steps of inference.\n",
      "Final absolute errors for the two variational parameters were 0.7947 & 0.7989\n"
     ]
    }
   ],
   "source": [
    "import os\n",
    "import torch\n",
    "import torch.distributions.constraints as constraints\n",
    "import pyro\n",
    "import pyro.distributions as dist\n",
    "# Pyro also has a reparameterized Beta distribution so we import\n",
    "# the non-reparameterized version to make our point\n",
    "from pyro.distributions.testing.fakes import NonreparameterizedBeta\n",
    "import pyro.optim as optim\n",
    "from pyro.infer import SVI, TraceGraph_ELBO\n",
    "import sys\n",
    "\n",
    "# enable validation (e.g. validate parameters of distributions)\n",
    "assert pyro.__version__.startswith('1.3')\n",
    "pyro.enable_validation(True)\n",
    "\n",
    "# this is for running the notebook in our testing framework\n",
    "smoke_test = ('CI' in os.environ)\n",
    "max_steps = 2 if smoke_test else 10000\n",
    "\n",
    "\n",
    "def param_abs_error(name, target):\n",
    "    return torch.sum(torch.abs(target - pyro.param(name))).item()\n",
    "\n",
    "\n",
    "class BernoulliBetaExample:\n",
    "    def __init__(self, max_steps):\n",
    "        # the maximum number of inference steps we do\n",
    "        self.max_steps = max_steps\n",
    "        # the two hyperparameters for the beta prior\n",
    "        self.alpha0 = 10.0\n",
    "        self.beta0 = 10.0\n",
    "        # the dataset consists of six 1s and four 0s\n",
    "        self.data = torch.zeros(10)\n",
    "        self.data[0:6] = torch.ones(6)\n",
    "        self.n_data = self.data.size(0)\n",
    "        # compute the alpha parameter of the exact beta posterior\n",
    "        self.alpha_n = self.data.sum() + self.alpha0\n",
    "        # compute the beta parameter of the exact beta posterior\n",
    "        self.beta_n = - self.data.sum() + torch.tensor(self.beta0 + self.n_data)\n",
    "        # initial values of the two variational parameters\n",
    "        self.alpha_q_0 = 15.0\n",
    "        self.beta_q_0 = 15.0\n",
    "\n",
    "    def model(self, use_decaying_avg_baseline):\n",
    "        # sample `latent_fairness` from the beta prior\n",
    "        f = pyro.sample(\"latent_fairness\", dist.Beta(self.alpha0, self.beta0))\n",
    "        # use plate to indicate that the observations are\n",
    "        # conditionally independent given f and get vectorization\n",
    "        with pyro.plate(\"data_plate\"):\n",
    "            # observe all ten datapoints using the bernoulli likelihood\n",
    "            pyro.sample(\"obs\", dist.Bernoulli(f), obs=self.data)\n",
    "\n",
    "    def guide(self, use_decaying_avg_baseline):\n",
    "        # register the two variational parameters with pyro\n",
    "        alpha_q = pyro.param(\"alpha_q\", torch.tensor(self.alpha_q_0),\n",
    "                             constraint=constraints.positive)\n",
    "        beta_q = pyro.param(\"beta_q\", torch.tensor(self.beta_q_0),\n",
    "                            constraint=constraints.positive)\n",
    "        # sample f from the beta variational distribution\n",
    "        baseline_dict = {'use_decaying_avg_baseline': use_decaying_avg_baseline,\n",
    "                         'baseline_beta': 0.90}\n",
    "        # note that the baseline_dict specifies whether we're using\n",
    "        # decaying average baselines or not\n",
    "        pyro.sample(\"latent_fairness\", NonreparameterizedBeta(alpha_q, beta_q),\n",
    "                    infer=dict(baseline=baseline_dict))\n",
    "\n",
    "    def do_inference(self, use_decaying_avg_baseline, tolerance=0.80):\n",
    "        # clear the param store in case we're in a REPL\n",
    "        pyro.clear_param_store()\n",
    "        # setup the optimizer and the inference algorithm\n",
    "        optimizer = optim.Adam({\"lr\": .0005, \"betas\": (0.93, 0.999)})\n",
    "        svi = SVI(self.model, self.guide, optimizer, loss=TraceGraph_ELBO())\n",
    "        print(\"Doing inference with use_decaying_avg_baseline=%s\" % use_decaying_avg_baseline)\n",
    "\n",
    "        # do up to this many steps of inference\n",
    "        for k in range(self.max_steps):\n",
    "            svi.step(use_decaying_avg_baseline)\n",
    "            if k % 100 == 0:\n",
    "                print('.', end='')\n",
    "                sys.stdout.flush()\n",
    "\n",
    "            # compute the distance to the parameters of the true posterior\n",
    "            alpha_error = param_abs_error(\"alpha_q\", self.alpha_n)\n",
    "            beta_error = param_abs_error(\"beta_q\", self.beta_n)\n",
    "\n",
    "            # stop inference early if we're close to the true posterior\n",
    "            if alpha_error < tolerance and beta_error < tolerance:\n",
    "                break\n",
    "\n",
    "        print(\"\\nDid %d steps of inference.\" % k)\n",
    "        print((\"Final absolute errors for the two variational parameters \" +\n",
    "               \"were %.4f & %.4f\") % (alpha_error, beta_error))\n",
    "\n",
    "# do the experiment\n",
    "bbe = BernoulliBetaExample(max_steps=max_steps)\n",
    "bbe.do_inference(use_decaying_avg_baseline=True)\n",
    "bbe.do_inference(use_decaying_avg_baseline=False)\n",
    "\n"
   ],
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%%\n"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sample tensor(-0.1185)\n",
      "log prob tensor(-0.9260)\n"
     ]
    }
   ],
   "source": [
    "loc = 0.   # mean zero\n",
    "scale = 1. # unit variance\n",
    "normal = torch.distributions.Normal(loc, scale) # create a normal distribution object\n",
    "y = normal.rsample() # draw a sample from N(0,1)\n",
    "print(\"sample\", x)\n",
    "print(\"log prob\", normal.log_prob(x)) # score the sample from N(0,1)\n"
   ],
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%%\n"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/psyphh/PycharmProjects/tip/venv/lib/python3.7/site-packages/pyro/primitives.py:86: RuntimeWarning: trying to observe a value outside of inference at my_sample\n",
      "  RuntimeWarning)\n"
     ]
    },
    {
     "data": {
      "text/plain": "tensor([-0.3521])"
     },
     "execution_count": 28,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "pyro.sample(\"my_sample\", pyro.distributions.Normal(loc, scale), obs=torch.tensor([y]))"
   ],
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%%\n"
    }
   }
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}